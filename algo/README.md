
### 排序算法
#### 冒泡排序（Bubble Sort）
冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。
当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。
最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 O(n)。
而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 O(n^2)。
平均情况下的时间复杂度就是 O(n^2)。

#### 插入排序（Insertion Sort）
将数组中的数据分为两个区间，已排序区间和未排序区间。
插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。
不需要额外的存储空间，所以空间复杂度是 O(1)，是一个原地排序算法。
对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。
要排序的数据已经是有序的，最好是时间复杂度为 O(n)。
如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，最坏情况时间复杂度为 O(n^2)。
在数组中插入一个数据的平均时间复杂度是O(n)，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，平均时间复杂度为 O(n^2)。

#### 归并排序（Merge Sort）
如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。
分治是一种解决问题的处理思想，递归是一种编程技巧。
归并排序是一个稳定的排序算法。
归并排序的时间复杂度是 O(nlogn)。
归并排序不是原地排序算法，空间复杂度是 O(n)。

#### 快速排序（Quicksort）
快排利用的也是分治思想。
归并排序的处理过程是由下到上的，先处理子问题，然后再合并。
而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。
快速排序不是一个稳定的排序算法。
快排的最好情况时间复杂度是 O(nlogn) ，最坏情况时间复杂度是 O(n^2)，平均情况时间复杂度是 O(nlogn)。

#### 堆排序
堆是一种特殊的树，是一个完全二叉树。堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。
分为大顶堆和小顶堆，建堆的时间复杂度就是 O(n)。
堆排序的时间复杂度非常稳定，是 O(nlogn)，并且它还是原地排序算法，但不是稳定的排序算法。
堆排序数据访问的方式没有快速排序友好；对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。

### 数据结构
#### 散列表
散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。

#### 基于散列表的LRU算法
散列表是通过链表法解决散列冲突的，所以每个结点会在两条链中。一个链是双向链表，另一个链是散列表中的拉链（HashMap内部处理了）。前驱和后继指针是为了将结点串在双向链表中。

#### 二叉查找树 BST
Binary Search Tree
二叉查找树中，每个节点的值都大于左子树节点的值，小于右子树节点的值。
中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)，非常高效。
