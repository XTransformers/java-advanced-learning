
#### 冒泡排序（Bubble Sort）
冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。
当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。
最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 O(n)。
而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 O(n^2)。
平均情况下的时间复杂度就是 O(n^2)。

#### 散列表
散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。

#### 基于散列表的LRU算法
散列表是通过链表法解决散列冲突的，所以每个结点会在两条链中。一个链是双向链表，另一个链是散列表中的拉链（HashMap内部处理了）。前驱和后继指针是为了将结点串在双向链表中。

#### 二叉查找树 BST
Binary Search Tree
二叉查找树中，每个节点的值都大于左子树节点的值，小于右子树节点的值。
中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)，非常高效。
